module ch.fhnw.fregels.Main where

import Control.monad.trans.EitherT(left)
import Data.JSON
import Java.IO as JIO()

import ch.fhnw.fregels.compile.CompileOptions(defaultLogFile)
import ch.fhnw.fregels.AppM(AppM, runAppM, ServerState(), initialState, ServerError(Error))
import ch.fhnw.fregels.io.IO(sendServerMessage, readMessage, createFile)
import ch.fhnw.fregels.messages.Message(processClientMessage)
import ch.fhnw.fregels.messages.MessageTypes(ServerMessage, Method)
import ch.fhnw.fregels.logger.Logger(getFileLogger, printWriterLog, Logger)
import ch.fhnw.fregels.rpc.Rpc(decodeMessage)

main []             = main [defaultLogFile]
main (logFile : _) = do
     loggingSetup <- createFile logFile
     if loggingSetup then do
       logger <- getFileLogger logFile
       let log = printWriterLog logger
       startLsp log
     else do
       JIO.stderr.println "Could not initialize log file, exiting"
       System.exit 1
     
startLsp :: Logger -> IO ()
startLsp log = do
  log "Started Frege LSP"
  st <- initialState
  forever (mainLoop st log)
      `catch` eof log
      `finally` 
        log "Shutting down after error occurance" 
          >> System.exit 1
    where
      eof :: Logger -> EOFException -> IO ()
      eof log e = log $ "an error occurred" ++ e.getMessage

mainLoop :: ServerState -> (String -> IO ()) -> IO ()
mainLoop st logger = do 
  (length, newMessage) <- readMessage
  (Method method) <-  parseJSON newMessage
  logger ("Received \"" ++ method ++ "\"-message with length: " ++ show length)
  (result, st) <- runAppM st $ handleClientMessage newMessage
  case result of 
    Left  (Error err) -> logger $ "An error occured: " ++ err
    Right (Just msg) -> sendServerMessage msg
    otherwise        -> pure ()
  mainLoop st logger

handleClientMessage :: String -> AppM (Maybe ServerMessage)
handleClientMessage newMessage = do
  request         <- liftToApp . decodeMessage $ newMessage
  maybeResponse   <- processClientMessage request
  pure maybeResponse
    where 
      liftToApp :: (String | a) -> AppM a
      liftToApp (Right a)  = pure a
      liftToApp (Left err) = left . Error $ err

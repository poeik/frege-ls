module ch.fhnw.fson.parser.Parser where

import ch.fhnw.fson.parser.Alternative
import Data.Char (isDigit, isAlpha)
import Data.Traversable (traverse)
import frege.Prelude

data Position = Position { line :: Int,  column :: Int }

instance Show Position where
  show :: Position -> String
  show p = "line: " ++ show p.line ++ ", column: " ++ show p.column

derive Eq Position
derive Ord Position

data ParseError = ParseError { errorPos :: Position, errorMsg :: String }

derive Show ParseError
derive Eq ParseError

data ParseState = ParseState { remaining :: String, position :: Position }

derive Show ParseState
derive Eq ParseState

-- TODO: can we somehow do better here than using data
data Parser a = Parser { runParser :: ParseState -> Either ParseError (a, ParseState) }

failWith :: String -> Parser a
failWith msg = do 
  pos <- currentPos
  Parser $ \_ ->
    Left $ ParseError pos msg

instance Functor Parser where
  fmap :: (a -> b) -> Parser a -> Parser b
  fmap f p = Parser $ \st ->
    case p.runParser st of
      Right (a, st') -> Right (f a, st')
      Left a         -> Left a

instance Applicative Parser where
  pure :: a -> Parser a
  pure a = Parser $ \st -> Right (a, st)

  (<*>) :: Parser (a -> b) -> Parser a -> Parser b
  (<*>) pf pa = Parser $ \st -> 
    case pf.runParser st of
      Right (f, st') -> 
        case pa.runParser st' of
          Right (a, st'') -> Right (f a, st'')
          Left a          -> Left a
      Left a         -> Left a
          
instance Monad Parser where
  (>>=) :: (Parser a) -> (a -> Parser b) -> Parser b 
  (>>=) pa pf = Parser $ \st -> 
    case pa.runParser st of
      Right (a, st') -> (pf a).runParser st'
      Left a         -> Left a

instance Alt Parser where
  (<|>) :: Parser a -> Parser a ->  Parser a
  (<|>) pA pB = Parser $ \st -> 
      case pA.runParser st of
        Left err1  -> 
          case pB.runParser st of
            Left err2 -> Left $ chooseFurthestError err1 err2
            Right a   -> Right a
        Right a -> Right a
    where 
      -- both alternatives failed. Which error do we propagate? 
      -- We choose the one which failed later!
      chooseFurthestError :: ParseError -> ParseError -> ParseError
      chooseFurthestError err1 err2 = 
        if err2.errorPos >= err1.errorPos then err2 else err1


nextChar :: Parser Char
nextChar = Parser $ \(ParseState input pos) -> 
  case unpacked (input) of
    []     -> Left $ ParseError pos "Unexpected end of input"
    (c:cs) -> Right $ (c, ParseState (packed cs) (updatePos pos c))
  where
    updatePos :: Position -> Char -> Position
    updatePos (Position l c) ch
      | ch == '\n' = Position (l + 1) 1
      | otherwise  = Position l (c + 1)

currentPos :: Parser Position
currentPos = Parser $ \(st@(ParseState _ pos)) -> Right (pos, st)

satisfyWith :: (Char -> Bool) -> (Char -> String) -> Parser Char
satisfyWith predicate msg = do
  c <- nextChar
  if predicate c then
    pure c
  else
    failWith $ msg c

satisfy :: (Char -> Bool) -> Parser Char
satisfy predicate = 
 satisfyWith predicate (\c -> "Unexpected character " ++ show c)

char :: Char -> Parser Char
char expected = 
  satisfyWith 
    ((==) expected) 
    (\c -> ("Expected " ++ show expected ++ ", but got " ++ show c))

string :: String -> Parser String
string s =  fmap packed $ traverse char (unpacked s)

integer :: Parser Int
integer = do
  digits <- some $ satisfy isDigit
  pure $ (read . packed) digits

identifier :: Parser String
identifier = do
  first <- satisfy isAlpha
  rest  <- many $ satisfy (\c -> isAlpha c || isDigit c)
  pure $ packed (first:rest)

unit :: Parser a -> Parser ()
unit = fmap $ const ()

whitespace :: Parser ()
whitespace = unit $ char ' '

newline :: Parser ()
newline = unit $ char '\n'

tab :: Parser ()
tab = unit $ char '\t'

space :: Parser ()
space = whitespace <|> newline <|> tab

mSpace :: Parser ()
mSpace = unit $ many space

token :: Parser a -> Parser a
token p = mSpace *> p <* mSpace

parseUntil :: Char -> Parser String
parseUntil c = parseUntil' ""
  where 
    parseUntil' acc = do
      n <- nextChar
      if n == c then
        pure acc
      else 
        parseUntil' (acc ++ packed [c])

parse :: Parser a -> String -> Either ParseError a
parse p input =
  case p.runParser (ParseState input (Position 1 0)) of
    Left err -> Left err
    Right (result, st) ->
      if null st.remaining then
        Right result
      else Left $ ParseError st.position "Parser did not consume entire input"

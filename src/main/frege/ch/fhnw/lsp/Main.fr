module ch.fhnw.lsp.Main where

import Control.monad.trans.EitherT
import Data.JSON
import Java.IO as JIO()

import ch.fhnw.lsp.logger.Logger(getFileLogger, printWriterLog, Logger)
import ch.fhnw.lsp.rpc.Rpc(decodeMessage)
import ch.fhnw.lsp.messages.Message(processClientMessage)
import ch.fhnw.lsp.messages.MessageTypes(ServerMessage, Method)
import ch.fhnw.lsp.env.LspEnv(runLspEnv, LspEnv, liftMonad, liftEither, logInfo)
import ch.fhnw.lsp.env.LspState(initialState, LspState, ServerError(Error))
import ch.fhnw.lsp.io.IO(sendServerMessage, readMessage, createFile)
import ch.fhnw.lsp.compile.CompileOptions(defaultLogFile)

main []             = main [defaultLogFile]
main (logFile : _) = do
     loggingSetup <- createFile logFile
     if loggingSetup then do
       logger <- getFileLogger logFile
       let log = printWriterLog logger
       startLsp log
     else do
       JIO.stderr.println "Could not initialize log file, exiting"
       System.exit 1
     
startLsp :: Logger IO -> IO ()
startLsp log = do
  log "Started Frege LSP"
  st <- initialState log
  forever (mainLoop st)
      `catch` eof log
      `finally` 
        log "Shutting down after error occurance" 
          >> System.exit 1
    where
      eof :: Logger IO -> EOFException -> IO ()
      eof log e = log $ "an error occurred" ++ e.getMessage

mainLoop :: LspState IO -> IO ()
mainLoop st = do 
  (result, st) <- runLspEnv st $ handleClientMessage
  case result of 
    Left  (Error err) -> st.logger $ "An error occured: " ++ err
    Right (Just msg) -> sendServerMessage msg
    otherwise        -> pure ()
  mainLoop st

handleClientMessage :: LspEnv IO (Maybe ServerMessage)
handleClientMessage = do
  (length, newMessage) <- liftMonad readMessage
  (Method method)      <- liftEither $ parseJSON newMessage
  logInfo ("Received \"" ++ method ++ "\"-message with length: " ++ show length)
  request        <- liftEither $ decodeMessage newMessage
  maybeResponse  <- processClientMessage request
  pure maybeResponse

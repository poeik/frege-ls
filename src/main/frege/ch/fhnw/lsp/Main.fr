module ch.fhnw.lsp.Main where

import Control.monad.trans.MonadIO
import Control.monad.trans.EitherT
import Data.JSON

import ch.fhnw.lsp.logger.Logger
import ch.fhnw.lsp.rpc.Rpc
import ch.fhnw.lsp.messages.Messages
import ch.fhnw.lsp.rpc.Response
import ch.fhnw.lsp.rpc.Request
import ch.fhnw.lsp.env.LspEnv

pure native fromChars "new java.lang.String" :: JArray Char -> String

main []             = startLsp swallowLog
main (filePath : _) = do
     logger     <- getFileLogger filePath
     let log = printWriterLog logger
     startLsp log
     
startLsp :: Logger -> IO ()
startLsp log = do
 log "Started Frege LSP"
 forever (mainLoop log)
      `catch` eof log
      `finally` log "Shutting down Frege LSP"
    where
      eof :: Logger -> EOFException -> IO ()
      eof log e = log $ "an error occured" ++ e.getMessage

mainLoop :: (String->IO ()) -> IO ()
mainLoop log = do 
  result <- EitherT.run $ handleMessage log
  case result of 
    Right response -> sendResponse response
    Left err -> log $ "An error occured: " ++ err
  mainLoop log

handleMessage :: Logger -> LspEnv Response
handleMessage log = do
  (length, newMessage) <- liftIO readMessage
  (Method method) <- liftEither $ parseJSON newMessage
  liftIO $ log ("Received \"" ++ method ++ "\"-message with length: " ++ show length)
  request <- liftEither $ decodeMessage newMessage
  response  <- processMessage log request
  pure response

sendResponse :: Response -> IO ()
sendResponse EmptyResponse = pure ()
sendResponse msg           = println $ encodeMessage msg

readMessage :: IO (Int, String)
readMessage = do
  header     <- getLine
  _          <- getLine
  let length = extractMessageLength header
  message    <- readChars length
  pure $ (length, message)

readChars :: Int -> IO String
readChars amt = do
  arr <- newArray amt
  let offset = 0
  length <- stdin.read arr offset amt
  readonly fromChars arr

module ch.fhnw.lsp.Main where

import Control.monad.trans.EitherT
import Data.JSON

import ch.fhnw.lsp.logger.Logger(swallowLog, getFileLogger, printWriterLog, Logger)
import ch.fhnw.lsp.rpc.Rpc(decodeMessage)
import ch.fhnw.lsp.messages.Message(processClientMessage)
import ch.fhnw.lsp.messages.MessageTypes(ServerMessage, Method)
import ch.fhnw.lsp.env.LspEnv(runLspEnv, LspEnv, liftMonad, liftEither, logInfo)
import ch.fhnw.lsp.env.LspState(initialState, LspState, ServerError(Error))
import ch.fhnw.lsp.io.IO(sendServerMessage, readMessage)

main []             = startLsp swallowLog
main (filePath : _) = do
     logger     <- getFileLogger filePath
     let log = printWriterLog logger
     startLsp log
     
startLsp :: Logger IO -> IO ()
startLsp log = do
  log "Started Frege LSP"
  st <- initialState log
  forever (mainLoop st)
      `catch` eof log
      `finally` 
        log "Shutting down after error occurance" 
          >> System.exit 1
    where
      eof :: Logger IO -> EOFException -> IO ()
      eof log e = log $ "an error occurred" ++ e.getMessage

mainLoop :: LspState IO -> IO ()
mainLoop st = do 
  (result, st) <- runLspEnv st $ handleClientMessage
  case result of 
    Left  (Error err) -> st.logger $ "An error occured: " ++ err
    Right (Just msg) -> sendServerMessage msg
    otherwise        -> pure ()
  mainLoop st

handleClientMessage :: LspEnv IO (Maybe ServerMessage)
handleClientMessage = do
  (length, newMessage) <- liftMonad readMessage
  (Method method)      <- liftEither $ parseJSON newMessage
  logInfo ("Received \"" ++ method ++ "\"-message with length: " ++ show length)
  request        <- liftEither $ decodeMessage newMessage
  maybeResponse  <- processClientMessage request
  pure maybeResponse

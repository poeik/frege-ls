module ch.fhnw.lsp.Main where

import Control.monad.trans.EitherT
import Data.JSON

import ch.fhnw.lsp.logger.Logger
import ch.fhnw.lsp.rpc.Rpc
import ch.fhnw.lsp.messages.Messages
import ch.fhnw.lsp.env.LspEnv
import ch.fhnw.lsp.env.LspState

pure native fromChars "new java.lang.String" :: JArray Char -> String

main []             = startLsp swallowLog
main (filePath : _) = do
     logger     <- getFileLogger filePath
     let log = printWriterLog logger
     startLsp log
     
startLsp :: Logger IO -> IO ()
startLsp log = do
  log "Started Frege LSP"
  let st = initialState log
  forever (mainLoop st)
      `catch` eof log
      `finally` log "Shutting down Frege LSP"
    where
      eof :: Logger IO -> EOFException -> IO ()
      eof log e = log $ "an error occurred" ++ e.getMessage

mainLoop :: LspState IO -> IO ()
mainLoop st = do 
  (result, st) <- runLspEnv st $ handleMessage
  case result of 
    Left  (Error err) -> st.logger $ "An error occured: " ++ err
    Right response    -> sendResponse response
  mainLoop st

handleMessage :: LspEnv IO Response
handleMessage = do
  (length, newMessage) <- liftIO readMessage
  (Method method)      <- liftEither $ parseJSON newMessage
  logInfo ("Received \"" ++ method ++ "\"-message with length: " ++ show length)
  request   <- liftEither $ decodeMessage newMessage
  response  <- processMessage request
  pure response

sendResponse :: Response -> IO ()
sendResponse EmptyResponse = pure ()
sendResponse msg           = println $ encodeMessage msg

readMessage :: IO (Int, String)
readMessage = do
  header     <- getLine
  _          <- getLine
  let length = extractMessageLength header
  message    <- readChars length
  pure $ (length, message)

readChars :: Int -> IO String
readChars amt = do
  arr <- newArray amt
  let offset = 0
  length <- stdin.read arr offset amt
  readonly fromChars arr

module ch.fhnw.lsp.Main where

import Control.monad.trans.EitherT(left)
import Data.JSON
import Java.IO as JIO()

import ch.fhnw.lsp.compile.CompileOptions(defaultLogFile)
import ch.fhnw.lsp.AppM(AppM, runAppM, ServerState(), initialState, ServerError(Error))
import ch.fhnw.lsp.io.IO(sendServerMessage, readMessage, createFile)
import ch.fhnw.lsp.messages.Message(processClientMessage)
import ch.fhnw.lsp.messages.MessageTypes(ServerMessage, Method)
import ch.fhnw.lsp.logger.Logger(getFileLogger, printWriterLog, Logger)
import ch.fhnw.lsp.rpc.Rpc(decodeMessage)

main []             = main [defaultLogFile]
main (logFile : _) = do
     loggingSetup <- createFile logFile
     if loggingSetup then do
       logger <- getFileLogger logFile
       let log = printWriterLog logger
       startLsp log
     else do
       JIO.stderr.println "Could not initialize log file, exiting"
       System.exit 1
     
startLsp :: Logger IO -> IO ()
startLsp log = do
  log "Started Frege LSP"
  st <- initialState
  forever (mainLoop st log)
      `catch` eof log
      `finally` 
        log "Shutting down after error occurance" 
          >> System.exit 1
    where
      eof :: Logger IO -> EOFException -> IO ()
      eof log e = log $ "an error occurred" ++ e.getMessage

mainLoop :: ServerState -> (String -> IO ()) -> IO ()
mainLoop st logger = do 
  (length, newMessage) <- readMessage
  (Method method) <-  parseJSON newMessage
  logger ("Received \"" ++ method ++ "\"-message with length: " ++ show length)
  (result, st) <- runAppM st $ handleClientMessage newMessage
  case result of 
    Left  (Error err) -> logger $ "An error occured: " ++ err
    Right (Just msg) -> sendServerMessage msg
    otherwise        -> pure ()
  mainLoop st logger

handleClientMessage :: String -> AppM (Maybe ServerMessage)
handleClientMessage newMessage = do
  request         <- liftToApp . decodeMessage  $ newMessage
  maybeResponse   <- processClientMessage request
  pure maybeResponse
    where 
      liftToApp :: (String | a) -> AppM a
      liftToApp (Right a)  = pure a
      liftToApp (Left err) = left . Error $ err

module ch.fhnw.lsp.Main where

import Control.monad.trans.MonadIO
import Control.monad.trans.EitherT

import ch.fhnw.lsp.logger.Logger
import ch.fhnw.lsp.rpc.Rpc
import ch.fhnw.lsp.rpc.Request
import ch.fhnw.lsp.rpc.Response

pure native fromChars "new java.lang.String" :: JArray Char -> String
type LspEnv a = EitherT String IO a

liftEither :: Either String a -> LspEnv a
liftEither = EitherT . pure

main []             = startLsp swallowLog
main (filePath : _) = do
     logger     <- getFileLogger filePath
     let log = printWriterLog logger
     startLsp log
     
startLsp :: Logger -> IO ()
startLsp log = do
 log "Started Frege LSP"
 forever (mainLoop log)
      `catch` eof log
      `finally` log "Shutting down Frege LSP"
    where
      mainLoop log = do 
        result <- EitherT.run $ handleMessage log
        case result of 
          Right response -> case response of
            InitializeResponse msg = log msg
          Left err -> log $ "An error occured: " ++ err
        mainLoop log
      eof :: Logger -> EOFException -> IO ()
      eof log e = log $ "an error occured" ++ e.getMessage

handleMessage :: Logger -> LspEnv Response
handleMessage log = do
  (length, newMessage) <- liftIO readMessage
  liftIO $ log ("Received message:\nlength: " ++ show length ++ "\nmessage: "++ newMessage)
  result <- processMessage log newMessage
  pure result

processMessage :: Logger -> String -> LspEnv Response
processMessage log message = do
  request <- liftEither $ decodeMessage message
  handleMessage request
  where 
    handleMessage :: Request -> LspEnv Response
    handleMessage msg = 
      case msg of
        InitializeRequest _ p -> processInitializeMessage log p 
    
processInitializeMessage :: Logger -> InitializeRequestParams -> LspEnv Response
processInitializeMessage log (InitializeRequestParams pid) = do
  liftIO (log $ "Connected to " ++ "PID: " ++ show pid)
  pure $ InitializeResponse (show pid)

sendResponse :: Response -> IO ()
sendResponse msg = println "sent"

readMessage :: IO (Int, String)
readMessage = do
  header     <- getLine
  _          <- getLine
  let length = extractMessageLength header
  message    <- readChars length
  pure $ (length, message)

readChars :: Int -> IO String
readChars amt = do
  arr <- newArray amt
  let offset = 0
  length <- stdin.read arr offset amt
  readonly fromChars arr

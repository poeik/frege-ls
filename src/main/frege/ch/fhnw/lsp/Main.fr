module ch.fhnw.lsp.Main where

import Control.monad.trans.EitherT()
import Control.monad.State(StateT(), State(), runStateT, promote)
import Data.JSON
import Java.IO as JIO()

import ch.fhnw.lsp.compile.CompileOptions(defaultLogFile)
import ch.fhnw.lsp.env.App(AppResult, runApp, liftToApp)
import ch.fhnw.lsp.env.LspState(asServerResult, initialState, LspState(), ServerError(Error))
import ch.fhnw.lsp.io.IO(sendServerMessage, readMessage, createFile)
import ch.fhnw.lsp.messages.Message(processClientMessage)
import ch.fhnw.lsp.messages.MessageTypes(ServerMessage, Method)
import ch.fhnw.lsp.logger.Logger(getFileLogger, printWriterLog, Logger)
import ch.fhnw.lsp.rpc.Rpc(decodeMessage)

main []             = main [defaultLogFile]
main (logFile : _) = do
     loggingSetup <- createFile logFile
     if loggingSetup then do
       logger <- getFileLogger logFile
       let log = printWriterLog logger
       startLsp log
     else do
       JIO.stderr.println "Could not initialize log file, exiting"
       System.exit 1
     
startLsp :: Logger IO -> IO ()
startLsp log = do
  log "Started Frege LSP"
  st <- initialState
  forever (mainLoop st log)
      `catch` eof log
      `finally` 
        log "Shutting down after error occurance" 
          >> System.exit 1
    where
      eof :: Logger IO -> EOFException -> IO ()
      eof log e = log $ "an error occurred" ++ e.getMessage

mainLoop :: LspState -> (String -> IO ()) -> IO ()
mainLoop st logger = do 
  (length, newMessage) <- readMessage
  (Method method) <-  parseJSON newMessage
  logger ("Received \"" ++ method ++ "\"-message with length: " ++ show length)
  (result, st) <- runApp st $ handleClientMessage newMessage
  case result of 
    Left  (Error err) -> logger $ "An error occured: " ++ err
    Right (Just msg) -> sendServerMessage msg
    otherwise        -> pure ()
  mainLoop st logger

handleClientMessage :: String -> AppResult (StateT LspState IO) (Maybe ServerMessage)
handleClientMessage newMessage = do
  request         <- liftToApp . asServerResult . decodeMessage  $ newMessage
  maybeResponse   <- processClientMessage request
  pure maybeResponse

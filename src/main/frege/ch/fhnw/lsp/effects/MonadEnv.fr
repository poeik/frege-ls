module ch.fhnw.lsp.effects.MonadEnv where

import Control.concurrent.STM(TVar(), atomically)
import Control.monad.trans.EitherT(EitherT())
import Control.monad.trans.MonadIO(MonadIO(liftIO))

import ch.fhnw.lsp.AppM(AppM, AppStateM, ServerState(), runAppM, accessM)
import ch.fhnw.lsp.messages.GeneralLspTypes(URI())

class Monad m => MonadEnv m where
  projectRoot              :: () -> m (Maybe URI)
  waitingForCompilationRef :: () -> m (TVar Bool)
  setWaitForCompilationRef :: Bool -> m ()

instance (Monad AppStateM) => MonadEnv AppM where
  projectRoot              _ = accessM _.rootPath
  waitingForCompilationRef _ = accessM _.waitForCompilation
  setWaitForCompilationRef val = do
    waitRef <- accessM _.waitForCompilation
    liftIO $ atomically (TVar.write waitRef val)

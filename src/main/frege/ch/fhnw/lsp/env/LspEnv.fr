module ch.fhnw.lsp.env.LspEnv where

import Control.monad.trans.EitherT(EitherT, left)
import Control.monad.trans.MonadTrans as MT()
import Control.monad.trans.MonadIO as M()
import Compiler.types.NSNames(NSX)
import Control.monad.State(StateT(), State(), runStateT, promote)
import Compiler.types.Global(Global(), Options())
import Data.HashMap(HashMap(), union, fromList, lookup)
import Java.Lang(Runnable)
import Java.IO as JIO()
import Control.concurrent.STM(atomically, TVar)
import ch.fhnw.lsp.compile.CompileExecutorLSP(fromOptionsLSP)

import ch.fhnw.lsp.compile.CompileExecutorLSP(compileMakeLSP, compileMakeLSPInMemory)
import ch.fhnw.lsp.messages.GeneralLspTypes(URI)
import ch.fhnw.lsp.compile.CompileOptions(defaultLogFile)
import ch.fhnw.lsp.rpc.Rpc(encodeMessage)
import ch.fhnw.lsp.messages.MessageTypes(ServerMessage)
import ch.fhnw.lsp.logger.Logger(getFileLogger, printWriterLog, Logger)
import ch.fhnw.lsp.utils.Utils (note)
import ch.fhnw.lsp.env.LspState(ServerError, LspState, asServerResult, report, ServerResult)

-- TODO: cleanup old LspEnv stuff & move all implementations

type LspEnv m a = Monad m => EitherT ServerError (StateT LspState m) a
type AppResult m a = Monad m => EitherT ServerError m a

liftToApp :: Monad m => ServerResult a -> AppResult m a
liftToApp (Right a)  = pure a
liftToApp (Left err) = left err

-- TODO: remove
mayFail :: (Monad m, MonadFail m) => ServerResult a -> m a
mayFail (Right a)  = pure a
mayFail (Left (Error msg)) = fail msg

liftMaybe :: Monad m => String -> Maybe a -> LspEnv m a
liftMaybe msg m = liftResult (asServerResult (note id msg m))

hushMaybe :: Monad m => Maybe a -> LspEnv m a
hushMaybe = liftMaybe ""

hushMaybe' :: Monad m => Maybe a -> AppResult m a
hushMaybe' = liftMaybe' ""

liftMaybe' :: Monad m => String -> Maybe a -> AppResult m a
liftMaybe' msg m = liftToApp $ asServerResult (note id msg m)

liftState :: Monad m => State LspState a -> LspEnv m a
liftState st = MT.lift (promote st)

liftEither :: Monad m => (String | a) -> LspEnv m a
liftEither (Right a)  = pure a
liftEither (Left err) = liftResult $ report err

liftResult :: Monad m => ServerResult a -> LspEnv m a
liftResult (Right a)  = pure a
liftResult (Left err) = left err

liftIO :: (M.MonadIO m) => IO a -> LspEnv m a
liftIO = M.liftIO

liftMonad :: Monad m => m a -> LspEnv m a
liftMonad = MT.lift . MT.lift

get :: Monad m => LspEnv m LspState
get = MT.lift StateT.get

access :: Monad m => (LspState -> a) -> LspEnv m a
access accessor = fmap accessor get

put :: Monad m => LspState -> LspEnv m ()
put = MT.lift . StateT.put

modify :: Monad m => (LspState -> LspState) -> LspEnv m ()
modify = MT.lift . StateT.modify

runApp :: Monad m => LspState -> AppResult (StateT LspState m) a -> m (ServerResult a, LspState)
runApp st env = runStateT (EitherT.run env) st

class Monad m => MonadSystem m where
  systemExit :: m ()

instance (M.MonadIO m) => MonadSystem (StateT s m) where
  systemExit = M.liftIO $ System.exit 0

instance (MonadSystem m) => MonadSystem (EitherT e m) where
  systemExit = MT.lift systemExit

---  Our logging effect
class Monad m => MonadLog m where
  logInfo :: String -> m ()

instance (M.MonadIO m) => MonadLog (StateT s m) where
  logInfo :: (M.MonadIO m) => String -> StateT s m ()
  logInfo msg = do 
    logger <- M.liftIO $ getFileLogger defaultLogFile
    let log = printWriterLog logger
    M.liftIO $ log msg

instance MonadLog m => MonadLog (EitherT e m) where
  logInfo :: MonadLog m => String -> EitherT e m ()
  logInfo = MT.lift . logInfo

--- This effect enables to send a message from the server to the client 
class Monad m => MonadSendMessage m where
  sendServerMessage :: ServerMessage -> m ()

instance (M.MonadIO m) => MonadSendMessage (StateT s m) where
  sendServerMessage :: (M.MonadIO m) => ServerMessage -> StateT s m ()
  sendServerMessage = M.liftIO . println . encodeMessage

instance (MonadSendMessage m) => MonadSendMessage (EitherT e m) where
  sendServerMessage :: (MonadSendMessage m) => ServerMessage -> EitherT e m ()
  sendServerMessage = MT.lift . sendServerMessage

class Monad m => MonadGlobals m where
  readGlobals        :: m (HashMap URI Global)
  addGlobals         :: HashMap URI Global -> m ()
  projectGlobal      :: m (Maybe Global)
  waitForCompilation :: Long -> m ()

instance (M.MonadIO m) => MonadGlobals (StateT LspState m) where
  projectGlobal = fmap LspState.projectGlobal StateT.get
  readGlobals = do
    globals <- fmap (_.globals) StateT.get
    M.liftIO $ atomically (TVar.read globals)
  addGlobals newGlobals = do
    globals <- fmap (_.globals) StateT.get
    M.liftIO $ atomically do
      current <- TVar.read globals
      let result = union newGlobals current
      globals.write result

  {--
    This function reads the `watingForCompilation` state from `LspState`. If this
    TVar is set to `true` it blocks the current thread by sleeping for a short 
    period. Specify a suitable `maxWaitTime` which is the max amount of time 
    following computations in the monadic sequencing may be deferred.
  -}
  waitForCompilation :: (M.MonadIO m) => Long -> StateT LspState m ()
  waitForCompilation maxWaitTime
    | maxWaitTime < waitMsPerTry -> do 
        logInfo $ "Waited for " ++ "ms for compilation to complete, giving up."
        pure ()
    | otherwise -> do
        waiting <- isWaiting
        if waiting then do
          logInfo $ "Waiting for Compilation to complete"
          M.liftIO $ Thread.sleep waitMsPerTry
          waitForCompilation (maxWaitTime - waitMsPerTry)
        else pure ()
    where
      waitMsPerTry = 100
      where isWaiting = waitingForCompilationRef >>= M.liftIO . atomically . TVar.read 
  
instance (MonadGlobals m) => MonadGlobals (EitherT e m) where
  projectGlobal      = MT.lift projectGlobal
  readGlobals        = MT.lift readGlobals
  addGlobals         = MT.lift . addGlobals
  waitForCompilation = MT.lift . waitForCompilation

class Monad m => MonadEnv m where
  projectRoot              :: m (ServerResult URI)
  waitingForCompilationRef :: m (TVar Bool)
  setWaitForCompilationRef :: Bool -> m ()

instance (M.MonadIO m) => MonadEnv (StateT LspState m) where
  projectRoot           = fmap LspState.rootPath StateT.get
  waitingForCompilationRef = fmap (LspState.waitForCompilation) StateT.get
  setWaitForCompilationRef val = do
    waitRef <- waitingForCompilationRef
    M.liftIO $ atomically (TVar.write waitRef val)

instance (MonadEnv m) => MonadEnv (EitherT e m) where
  projectRoot              = MT.lift projectRoot
  waitingForCompilationRef = MT.lift waitingForCompilationRef
  setWaitForCompilationRef = MT.lift . setWaitForCompilationRef

class (Monad m) => MonadInitialize m where
  initializeEnvironment :: Options -> URI -> m ()
  setupCompileDir :: JIO.File -> m Bool

instance (M.MonadIO m) => MonadInitialize (StateT LspState m) where
  initializeEnvironment options rootDir = do
    global  <- M.liftIO $ fromOptionsLSP options
    StateT.modify (\cur -> cur.{ projectGlobal = Just global, rootPath = Right rootDir })
  setupCompileDir dir = M.liftIO dir.mkdirs

instance (MonadInitialize m) => MonadInitialize (EitherT e m) where
  initializeEnvironment opt uri = MT.lift $ initializeEnvironment opt uri
  setupCompileDir = MT.lift . setupCompileDir

class (MonadGlobals m) => MonadCompile m where
  compileFile             :: URI -> m (Maybe Global)
  compileInMemory         :: String -> URI -> m (Maybe Global)

instance (M.MonadIO m) => MonadCompile (StateT LspState m) where
  compileFile :: (M.MonadIO m) => URI -> StateT LspState m (Maybe Global)
  compileFile uriToCompile = do
    exists <- fileExists uriToCompile
    if exists then do 
      logInfo $ "Compiling: " ++ uriToCompile.path
      pglobal <- projectGlobal
      newGlobals <- case pglobal of
        Just g -> M.liftIO $ compileMakeLSP uriToCompile.path g
        Nothing -> pure []
      updateURIGlobals newGlobals uriToCompile
    else do
      logInfo $ "File \"" ++ uriToCompile.path ++ "\" does not exist"
      pure Nothing
    where 
      fileExists :: (M.MonadIO m) => URI -> StateT LspState m Bool
      fileExists uri = M.liftIO file.exists
        where 
          file = File.new uri.path
    compileInMemory sourceCodeToCompile belongingUri = do
      maybeProjectGlobal <- projectGlobal
      case maybeProjectGlobal of 
        Just projectGlobal -> do
          newGlobals <- M.liftIO $ compileMakeLSPInMemory belongingUri.path sourceCodeToCompile projectGlobal
          updateURIGlobals newGlobals belongingUri
        Nothing -> pure Nothing

data CompileDebouncer = native ch.fhnw.lsp.utils.compile.CompileDebouncer where
  native new      :: Int -> IOMutable CompileDebouncer 
  native trigger  :: MutableIO CompileDebouncer -> MutableIO Runnable -> IO ()
  native shutdown :: MutableIO CompileDebouncer -> IO ()


instance (MonadCompile m) => MonadCompile (EitherT e m) where
  compileFile      = MT.lift . compileFile
  compileInMemory src uri = MT.lift $ compileInMemory src uri

updateURIGlobals :: (
    MonadLog     m
  , MonadGlobals m
  ) => [Global] -> URI -> m (Maybe Global)
updateURIGlobals newGlobals openedUri = do
    logInfo $ "Adding " ++ show newGlobals.length ++ " globals: " ++ (show (map (URI.fromGlobal) newGlobals))
    let kv = map (\g -> (URI.fromGlobal g, g)) newGlobals
    let globalsMap = fromList kv
    addGlobals globalsMap
    updated <- readGlobals
    pure $ lookup openedUri updated

findGlobalForModule :: (
    MonadEnv     m
  , MonadCompile m
  ) => String -> Global -> AppResult m (Maybe Global)
findGlobalForModule moduleName sourceGlobal = do
  uri  <- findFileUriForImportedModule moduleName sourceGlobal
  g    <- findOrLoadGlobal uri
  pure g

findFileUriForImportedModule :: (
    MonadEnv     m 
  , MonadGlobals m
  ) => String -> Global -> AppResult m URI
findFileUriForImportedModule moduleName sourceGlobal = do
  let mod = NSX moduleName
  globals     <- readGlobals
  rootPath    <- projectRoot >>= liftToApp
  pack <- liftToApp $ case sourceGlobal.namespaces.lookup mod of 
    Nothing  -> report ("Could not find module " ++ show moduleName)
    Just ps  -> pure ps
  uri  <- liftToApp . asServerResult $ rootPath.fromPackage sourceGlobal pack
  pure uri

findOrLoadGlobal :: (
   MonadCompile m
  ) => URI -> m (Maybe Global)
findOrLoadGlobal uri = do
  globals <- readGlobals
  case (globals.lookup uri) of
    Just g  -> pure $ Just g
    Nothing -> compileFile uri


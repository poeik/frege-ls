module ch.fhnw.lsp.env.LspEnv where

import Control.monad.trans.EitherT
import Control.monad.trans.MonadTrans as MT()
import Control.monad.trans.MonadIO as M()
import Control.monad.State

import ch.fhnw.lsp.utils.Utils (note)
import ch.fhnw.lsp.env.LspState

type LspEnv m a = Monad m => EitherT ServerError (StateT (LspState m) m) a

liftMaybe :: Monad m => String -> Maybe a -> LspEnv m a
liftMaybe msg m = liftResult (asServerResult (note id msg m))

hushMaybe :: Monad m => Maybe a -> LspEnv m a
hushMaybe = liftMaybe ""

liftState :: Monad m => State (LspState m) a -> LspEnv m a
liftState st = MT.lift (promote st)

liftEither :: Monad m => (String | a) -> LspEnv m a
liftEither (Right a)  = pure a
liftEither (Left err) = liftResult $ report err

liftResult :: Monad m => ServerResult a -> LspEnv m a
liftResult (Right a)  = pure a
liftResult (Left err) = left err

liftIO :: IO a -> LspEnv IO a
liftIO = M.liftIO

liftMonad :: Monad m => m a -> LspEnv m a
liftMonad = MT.lift . MT.lift

get :: Monad m => LspEnv m (LspState m)
get = MT.lift StateT.get

access :: Monad m => (LspState m -> a) -> LspEnv m a
access accessor = fmap accessor get

put :: Monad m => LspState m -> LspEnv m ()
put = MT.lift . StateT.put

modify :: Monad m => (LspState m -> LspState m) -> LspEnv m ()
modify = MT.lift . StateT.modify

runLspEnv :: Monad m => LspState m -> LspEnv m a -> m (ServerResult a, LspState m)
runLspEnv st env = runStateT (EitherT.run env) st

logInfo :: Monad m => String -> LspEnv m ()
logInfo msg = do
  st <- get
  let l = st.logger
  liftMonad $ l msg


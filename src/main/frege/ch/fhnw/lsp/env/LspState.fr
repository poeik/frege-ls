module ch.fhnw.lsp.env.LspState where

import ch.fhnw.lsp.messages.GeneralLspTypes (URI)
import Data.HashMap
import Compiler.types.Global (Global, Options, SubSt)
import Control.concurrent.STM
import Control.monad.trans.MonadIO(MonadIO, liftIO)
import ch.fhnw.lsp.compile.CompileOptions(defaultLogFile)

type ServerResult a = (ServerError | a)
data ServerError = Error String

initialState :: IO LspState
initialState = do 
  globals             <- atomically $ TVar.new empty
  waitForCompilation  <- atomically $ TVar.new False
  pure LspState {
    rootPath           = report "No root path provided"
  , globals            = globals
  , waitForCompilation = waitForCompilation
  , projectGlobal      = Nothing
  , logFilePath        = defaultLogFile
  }

data LspState = LspState { 
  rootPath           :: ServerResult URI 
, globals            :: TVar (HashMap URI Global)
, waitForCompilation :: TVar Bool
, projectGlobal      :: Maybe Global
, logFilePath        :: String
}

report :: String -> ServerResult a
report = Left . Error

asServerResult :: (String | a) -> ServerResult a
asServerResult (Right a) = Right a
asServerResult (Left e)  = report e

setGlobals :: HashMap URI Global -> LspState -> IO ()
setGlobals newGlobals st = do
  atomically $ st.globals.write newGlobals

updateGlobals :: (MonadIO m) => HashMap URI Global -> LspState -> m ()
updateGlobals newGlobals st = liftIO $ atomically $ do
    values  <- st.globals.read
    let result = union newGlobals values
    st.globals.write result

setWaitForCompilation :: Bool -> LspState -> IO ()
setWaitForCompilation wait st = atomically $
    st.waitForCompilation.write wait

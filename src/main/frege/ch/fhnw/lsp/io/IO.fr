module ch.fhnw.lsp.io.IO where

import Java.Util(Path)
import Java.IO as JIO()

import ch.fhnw.lsp.rpc.Rpc(encodeMessage, extractMessageLength)
import ch.fhnw.lsp.messages.MessageTypes(ServerMessage)

pure native fromChars "new java.lang.String" :: JArray Char -> String

sendServerMessage :: ServerMessage -> IO ()
sendServerMessage = println . encodeMessage

readMessage :: IO (Int, String)
readMessage = do
  header     <- getLine
  _          <- getLine
  let length = extractMessageLength header
  message    <- readChars length
  pure $ (length, message)

readChars :: Int -> IO String
readChars amt = do
  arr    <- newArray amt
  let offset = 0
  length <- stdin.read arr offset amt
  msg    <- readonly fromChars arr
  -- We receive a chunk of bytes not chars, meaning the array we allocate 
  -- is too big when any character is a non ASCII-symbol. We therefore process 
  -- the message delete remaining null characters.
  pure $ (packed . filter nonNulls . unpacked) msg
  where
    nonNulls = (/=) '\u0000'

pure native fileToPath toPath :: File -> Path
native create "java.nio.file.Files.createFile" :: Path -> IO Path throws IOException

createFile :: String -> IO Bool
createFile path = do
    let file = JIO.File.new path
    parentExists <- case file.getParentFile of
      Just parent -> parent.mkdirs
      otherwise -> pure True

    if parentExists then do
      create $ fileToPath file
      pure True
    else pure False
  `catch` 
    \(e :: IOException) -> pure False

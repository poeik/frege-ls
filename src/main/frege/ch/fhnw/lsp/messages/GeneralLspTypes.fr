module ch.fhnw.lsp.messages.GeneralLspTypes where

import Compiler.types.Global(Global())
import Compiler.types.Packs(Pack())
import Data.JSON(FromJSON(fromJSON), ToJSON(toJSON), Value(Struct, Number, String), field)

data TextDocument = TextDocument {
  uri :: URI
}
derive Show TextDocument

data TextDocumentItem = TextDocumentItem {
  uri         :: URI
, languageId  :: String
, version     :: FileVersion
, text        :: String
}
derive Show TextDocumentItem

data FileVersion = FileVersion Int
derive Show FileVersion

data Location = Location {
  uri   :: URI 
, range :: Range
}

derive Show Location

data Range = Range {
  start :: Position
, end   :: Position
}
derive Show Range

data Position = Position {
  line      :: Int
, character :: Int
}

derive Show Position

{-
  How LSP handles its URIs: taken from the 
  [LSP documentation](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#uri)

  foo://example.com:8042/over/there?name=ferret#nose
  \_/   \______________/\_________/ \_________/ \__/
   |           |            |            |        |
scheme     authority       path        query   fragment
   |   _____________________|__
  / \ /                        \
  urn:example:animal:ferret:nose
-}

data URISyntaxException = native java.net.URISyntaxException where
  pure native getMessage :: URISyntaxException -> String

derive Exceptional URISyntaxException 

native uriFromString "new java.net.URI" :: String -> STMutable s URI throws URISyntaxException


data URI = native java.net.URI where  
  pure native toString :: URI -> String
  pure native equals   :: URI -> URI -> Bool
  pure native hashCode :: URI -> Int
  pure native getPath  :: URI -> String

  withFileScheme = (++) "file://" 
  fromGlobal   :: Global -> (String | URI)
  fromGlobal global = fromString $ withFileScheme global.options.source
  fromPackage :: URI -> Global -> Pack -> (String | URI)
  fromPackage r g p 
    | p.raw == "" -> Left "Cannot create uri from empty package"
    | otherwise   -> (fromString . withFileScheme) $ path 
    where 
      path = concat [r.getPath, "/", concat g.sourcePath, replaceDotWithSlash (Global.unpack g p), ".fr"] 
      replaceDotWithSlash s = s.replace '.' '/'
  fromString      :: String -> (String | URI)
  fromString s    = ST.run
    (do
      uri <- fmap (readonly id) (uriFromString s)
      x   <- uri
      pure (Right x)
    `catch`
      \(e :: URISyntaxException) -> pure $ Left e.getMessage)

instance Show URI where show = URI.toString
instance Eq   URI where (==) = URI.equals

data MarkupContent = MarkupContent {
  kind  :: MarkupKind
, value :: String
}
derive Show MarkupContent

data MarkupKind = PlainText | Markdown
derive Show MarkupKind

-------------  FromJSON instances ------------- 

instance FromJSON URI where
  fromJSON (String s) = 
    case URI.fromString s of
      Right uri -> pure uri
      Left err  -> fail err
  fromJSON garbage = fail ("couldn't decode URI from: " ++ show garbage)

instance FromJSON TextDocument where
  fromJSON (Struct as) = do
    uri <- field "uri" as
    pure TextDocument { uri }
  fromJSON garbage = fail ("couldn't decode TextDocument from: " ++ show garbage)

instance FromJSON FileVersion where
  fromJSON (Number version) = pure $ FileVersion (read version)
  fromJSON garbage = fail ("couldn't decode TextDocument from: " ++ show garbage)

instance FromJSON TextDocumentItem where
  fromJSON (Struct as) = do
    uri         <- field "uri" as
    languageId  <- field "languageId" as
    version     <- field "version" as
    text        <- field "text" as
    pure TextDocumentItem { 
      uri = uri
    , languageId = languageId
    , version = version
    , text = text 
    }
  fromJSON garbage = fail ("couldn't decode TextDocumentItem from: " ++ show garbage)

instance FromJSON Location where
  fromJSON (Struct as) = do
    uri   <- field "uri" as
    range <- field "range" as
    pure Location { uri, range }
  fromJSON garbage = fail ("couldn't decode Location from: " ++ show garbage)

instance FromJSON Position where
  fromJSON (Struct as) = do
    -- the Frege Compiler uses 1 based characters & lines 
    -- LSP 0 based.
    -- We transform it here to forget about it.
    line      <- fmap (+1) $ field "line" as
    character <- fmap (+1) $ field "character" as
    pure Position { line, character  }
  fromJSON garbage = fail ("couldn't decode Position from: " ++ show garbage)

instance FromJSON Range where
  fromJSON (Struct as) = do
    start <- field "start" as
    end   <- field "end" as
    pure Range { start, end }
  fromJSON garbage = fail ("couldn't decode Range from: " ++ show garbage)

------------- ToJSON instances ------------- 

instance ToJSON URI where
  toJSON = String . show

instance ToJSON Location where
  toJSON Location { uri, range } =
    Struct [ ("uri", toJSON uri)
           , ("range", toJSON range)
           ]

instance ToJSON Position where
  toJSON Position { line, character } =
    -- the Frege Compiler uses 1 based characters & lines 
    -- LSP 0 based.
    -- We transform it here to forget about it.
    Struct [ ("line",      toJSON $ line - 1)
           , ("character", toJSON $ character - 1)
           ]

instance ToJSON Range where
  toJSON Range { start, end } =
    Struct [ ("start", toJSON start)
           , ("end",   toJSON end)
           ]

instance ToJSON MarkupContent where
  toJSON MarkupContent { kind, value } =
    Struct [ ("kind",  toJSON kind)
           , ("value", toJSON value)
           ]

instance ToJSON MarkupKind where
  toJSON PlainText = toJSON "plaintext"
  toJSON Markdown  = toJSON "markdown"

instance ToJSON FileVersion where
  toJSON (FileVersion version) = Number $ show version

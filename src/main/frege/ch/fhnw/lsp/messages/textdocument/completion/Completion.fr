module ch.fhnw.lsp.messages.textdocument.completion.Completion where

import Control.concurrent.STM(atomically, TVar)
import Compiler.types.Tokens(Token)
import Compiler.types.Global(Global, Symbol)
import Compiler.types.SourceDefinitions(funbinding)
import Data.HashMap(HashMap)

import ch.fhnw.lsp.env.LspEnv(LspEnv, logInfo, access, liftResult, access, liftIO)
import ch.fhnw.lsp.utils.Globals(findGlobal,findGlobalForModule, readGlobals)
import ch.fhnw.lsp.utils.Utils(note, tokenAt)
import ch.fhnw.lsp.env.LspState(ServerResult, Error, report, asServerResult, Error)
import ch.fhnw.lsp.messages.textdocument.completion.CompletionTypes(CompletionList, CompletionItem, CompletionRequestParams)
import ch.fhnw.lsp.messages.textdocument.completion.RecordFieldCompletion(findMembers)
import ch.fhnw.lsp.messages.GeneralLspTypes(Position, URI)
import Compiler.types.QNames(QName)

processCompletionRequest :: CompletionRequestParams -> LspEnv IO CompletionList
processCompletionRequest params =
  case params.context >>= _.triggerCharacter of
    Just "." -> do
      waitForCompilation maxWaitForCompilationTime
      logInfo "analyzing completions"
      items <- completionList params
      pure CompletionList { isIncomplete = False, items = map CompletionItem items }
    _        -> pure $ CompletionList { isIncomplete = False, items = [] }
  where
    maxWaitForCompilationTime = 5000

completionList :: CompletionRequestParams -> LspEnv IO [String]
completionList params = do
  globals     <- readGlobals
  (token, sourceGlobal)   <- findToken params.position params.textDocument.uri globals
  case tokenToQName token sourceGlobal of
    -- lets find all members of the token
    Just qname -> pure $ findMembers qname sourceGlobal
    -- cannot resolve token. Try to load the members of the module 
    Nothing    -> resolveModule token sourceGlobal
  where
    resolveModule token sourceGlobal = do
      target <- findGlobalForModule token.value sourceGlobal
      maybeDefs = case target of
        Just a  ->  map funbinding a.sub.sourcedefs
        Nothing -> []
      let defs      = catMaybes maybeDefs
      let names     = map _.value defs
      pure names

findToken :: Position -> URI -> HashMap URI Global -> LspEnv IO (Token, Global)
findToken pos uri globals = do
  global <- liftResult $ findGlobal uri globals
  token <- liftResult $ tokenAt 
    pos.{character <- (\c -> c - 1)} -- we want the token before the `.`
    global
  pure (token, global)

tokenToQName :: Token -> Global -> Maybe QName
tokenToQName tok sourceGlobal = do
  case sourceGlobal.resolved tok of
    Just (Right qname) -> Just qname
    _ -> Nothing

waitForCompilation :: Long -> LspEnv IO ()
waitForCompilation maxWaitTime
  | maxWaitTime < waitMsPerTry -> do 
      logInfo $ "Waited for " ++ "ms for compilation to complete, giving up."
      pure ()
  | otherwise -> do
      waiting <- waitingForCompilation 
      if waiting then do
        logInfo $ "Waiting for Compilation to complete"
        liftIO $ Thread.sleep waitMsPerTry
        waitForCompilation (maxWaitTime - waitMsPerTry)
      else pure ()
  where
    waitMsPerTry = 100
    waitingForCompilation = access _.waitForCompilation >>= (liftIO . atomically . TVar.read)


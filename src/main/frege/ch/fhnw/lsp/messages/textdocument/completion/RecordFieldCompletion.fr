module ch.fhnw.lsp.messages.textdocument.completion.RecordFieldCompletion where

import ch.fhnw.lsp.messages.textdocument.completion.CompletionTypes(CompletionItem, CompletionItemKind(Function))

import Compiler.types.QNames(QName, TName)
import Control.monad.State(evalState, State)
import Compiler.types.Symbols(SymV, SymT)
import Compiler.types.Global(Global, Symbol)
import Compiler.types.QNames(QName, TName)
import Compiler.types.Types   (Sigma, ForAll, Rho, RhoTau, RhoFun, Tau, TCon, TApp)
import Data.TreeMap as TM (values)
import ch.fhnw.lsp.utils.Documentation(documentSymbol)

findMembers :: QName -> Global -> [CompletionItem]
findMembers qname sourceGlobal = case result of 
  Nothing -> []
  Just a  -> a
  where 
    result :: Maybe [CompletionItem]
    result = do
      symbol <- sourceGlobal.find qname 
      -- sigma has all the type informations we need
      let sigma = symbol.typ
      tname <- tNameFromSigma sigma
      let members = evalState (getFields tname) sourceGlobal 
      pure members

getFields :: QName -> State Global [CompletionItem]
getFields recTName = do
  g <- State.get
  case g.findit recTName of
    -- Now we have the type of the record, with env containing ctors, methods & 
    -- record accessors
    Just (SymT { env }) -> 
      pure
        [ completionItem g name sym
        | sym@(SymV { name = MName belongingTName name, typ }) <- values env
          -- only the fields on this tname
        , belongingTName == recTName
        ]
    -- not a record-type (or unknown name)
    _ -> pure []
    where 
      completionItem global name sym = CompletionItem name Function (documentSymbol global sym)

-- \ Get the name of the type ctor the sigma belongs to
tNameFromSigma :: Sigma -> Maybe QName
tNameFromSigma (ForAll _ rho) = rhoTName rho
  where 
    -- | map a Tau until you find the TCon at its head.
    tauTName :: Tau -> Maybe QName
    tauTName (TCon { name = t }) = Just t
    tauTName (TApp f _)          = tauTName f
    tauTName _                   = Nothing
    -- \ map a `rho` to a qname
    rhoTName :: Rho -> Maybe QName
    -- represents a const (e.g. `a :: X`)
    rhoTName (RhoTau _ tau) = tauTName tau
    -- a function (e.g. `a :: Monad m => a -> m String`)
    rhoTName (RhoFun _ _ r) = rhoTName r

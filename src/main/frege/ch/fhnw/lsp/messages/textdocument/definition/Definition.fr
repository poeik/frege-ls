module ch.fhnw.lsp.messages.textdocument.definition.Definition where

import Compiler.types.Global(Global, Symbol)
import Compiler.types.Positions as P()
import Compiler.types.QNames(QName(Local))
import Compiler.types.NSNames(NSName(NSX))
import Compiler.enums.TokenID as T()
import Compiler.types.Tokens(Token)
import Data.HashMap(HashMap, lookup)

import ch.fhnw.lsp.effects.MonadCompile(MonadCompile(compileFile))
import ch.fhnw.lsp.effects.MonadEnv(MonadEnv(projectRoot))
import ch.fhnw.lsp.effects.MonadGlobals(MonadGlobals(readGlobals))
import ch.fhnw.lsp.effects.MonadLog(MonadLog(logInfo))
import ch.fhnw.lsp.effects.MonadSendMessage(MonadSendMessage())
import ch.fhnw.lsp.env.App(AppResult, liftToApp)
import ch.fhnw.lsp.env.LspState(report, asServerResult, ServerError(Error), ServerResult)
import ch.fhnw.lsp.messages.GeneralLspTypes(Location(Location), URI(fromGlobal), Position(Position), Range(Range))
import ch.fhnw.lsp.messages.textdocument.definition.DefinitionTypes(DefinitionRequestParams())
import ch.fhnw.lsp.utils.Utils(tokenAt, note, hush, findGlobal)

processDefinitionMessage :: (
    MonadLog         m, 
    MonadSendMessage m, 
    MonadGlobals     m, 
    MonadEnv         m, 
    MonadCompile     m
  ) => DefinitionRequestParams -> AppResult m Location
processDefinitionMessage params = do
  let currentUri = params.textDocument.uri
  let cursorPos  = params.position
  globalsMap    <- readGlobals
  sourceGlobal  <- liftToApp $ findGlobal currentUri globalsMap
  cursorToken   <- liftToApp $ findToken  cursorPos sourceGlobal 
  logInfo $ "Token under cursor: " ++ show cursorToken
  (file, pos)   <- findPosition cursorToken sourceGlobal
  logInfo $ "Symbol in file: \"" ++ file.path ++ "\" at position \"" ++ show pos ++ "\"."
  range         <- liftToApp $ posToRange pos cursorToken
  pure Location { uri = file, range = range }

findPosition :: (
    MonadEnv     m, 
    MonadCompile m, 
    MonadLog     m, 
    MonadGlobals m
  ) => Token -> Global -> AppResult m (URI, P.Position)
findPosition cursorToken sourceGlobal = do 
  case sourceGlobal.resolved cursorToken of
    Nothing            -> liftToApp $ report ("Could not find a position for the given token: " ++ show cursorToken)
    Just (Left ())     -> resolveNamespace cursorToken sourceGlobal -- left means it is a namespace
    Just (Right qname) -> resolveQName qname sourceGlobal

resolveNamespace :: (
    MonadGlobals m'
  ) => Token -> Global -> AppResult m' (URI,P.Position)
resolveNamespace cursorToken sourceGlobal = do
  globals   <- readGlobals
  let moduleName = NSX cursorToken.value
  position <- liftToApp $ case sourceGlobal.sub.nsPos.lookup moduleName of 
    Nothing   -> report ("Could not find module " ++ show moduleName)
    Just pos  -> pure pos
  let fileUri = fromGlobal sourceGlobal
  pure (fileUri, position)

resolveQName :: (
    MonadLog     m', 
    MonadEnv     m', 
    MonadCompile m'
  ) => QName -> Global -> AppResult m' (URI, P.Position)
resolveQName qname sourceGlobal = do
   globals              <- readGlobals
   sourceSymbol         <- liftToApp $ note Error "No matching symbol for qname found" $ sourceGlobal.find qname
   (file, targetSymbol) <- getFile sourceGlobal sourceSymbol globals
   pure (file, targetSymbol.pos)

findToken :: Position -> Global -> ServerResult Token
findToken cursorPos global = do 
    token  <- tokenAt cursorPos global
    case token.tokid of 
      id | id == T.VARID || id == T.CONID || id == T.QUALIFIER || id == T.SOMEOP -> pure token
      t -> report $ "Token under cursor (" ++ show t ++ ") is not valid."

findSymbol :: Token -> Global -> ServerResult Symbol
findSymbol token global = findSymbol'
   where 
     findSymbol' = do
       qname  <- note Error "No matching qname found"  $ global.resolved token >>= hush
       sym    <- note Error "No matching symbol found" $ global.find qname
       pure sym

posToRange :: P.Position -> Token -> ServerResult Range
posToRange pos token = do
  let result = Range {
    start = Position { line = first.line, character = first.col }
  , end   = Position { line = last.line, character = last.col + len }
  }
  -- definition requests for prelude functions give an illegal source position
  if result.start.line < 1 || result.start.character <= 0 then
    report "Received illegal source position for this token"
  else pure result
  where 
    first = pos.first
    last  = pos.last
    len   = length token.value

getFile :: (
    MonadEnv     m, 
    MonadCompile m, 
    MonadLog     m
  ) => Global -> Symbol -> HashMap URI Global -> AppResult m (URI, Symbol)
getFile sourceGlobal sourceSymbol m = do
    r <- projectRoot >>= liftToApp
    case sourceSymbol.name of
      Local _ _ -> do 
        logInfo "The requested symbol is a local definition"
        let fileUri = URI.fromGlobal sourceGlobal
        pure (fileUri, sourceSymbol)
        undefined
      name -> do
        let pack = name.getpack
        file <- liftToApp $ asServerResult (URI.fromPackage r sourceGlobal pack)

        case lookup file m of
          Nothing -> do 
              maybeGlobal <- compileFile file
              case maybeGlobal of 
                Nothing -> do
                  -- if the file is not loaded as global right now, 
                  -- it is either an external package or a definition part of the prelude 
                  -- in this case we just jump to the line of the import
                  logInfo $ "no global found for " ++ show file
                  findImportPos r sourceGlobal sourceSymbol
                Just global ->
                  findPosition global file
          Just global -> findPosition global file
  where
    findSymbolInDifferentGlobal :: Global -> Symbol -> ServerResult Symbol
    findSymbolInDifferentGlobal g s = 
        note Error "No matching symbol found" $ g.find s.name
    findImportPos r sourceGlobal sourceSymbol = do
        let fileUri = URI.fromGlobal sourceGlobal
        pure (fileUri, sourceSymbol)
    findPosition global file = do
        sym <- liftToApp $ findSymbolInDifferentGlobal global sourceSymbol
        logInfo $ "loaded as global: " ++ show file
        pure (file, sym)

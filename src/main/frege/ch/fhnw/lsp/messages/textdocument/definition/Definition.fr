module ch.fhnw.lsp.messages.textdocument.Definition where

import Compiler.types.Global(Global, Symbol)
import Compiler.types.Positions as P()
import Compiler.types.Symbols
import Compiler.types.QNames
import Compiler.enums.TokenID as T()
import Compiler.types.Tokens(Token)
import Data.HashMap
import Data.List(find)

import ch.fhnw.lsp.env.LspEnv
import ch.fhnw.lsp.utils.Globals(updateURIGlobals)
import ch.fhnw.lsp.env.LspState
import ch.fhnw.lsp.messages.GeneralLspTypes
import ch.fhnw.lsp.messages.textdocument.DefinitionTypes
import ch.fhnw.lsp.utils.Utils

processDefinitionMessage :: DefinitionRequestParams -> LspEnv IO Location
processDefinitionMessage params = do
  let currentUri = params.textDocument.uri
  let cursorPos  = params.position
  globalsMap    <- access _.globals
  sourceGlobal  <- liftResult $ findGlobal currentUri globalsMap
  cursorToken   <- liftResult $ findToken  cursorPos sourceGlobal 
  logInfo $ "Token under cursor: " ++ show cursorToken
  sourceSymbol  <- liftResult $ findSymbol cursorToken sourceGlobal 
  projectRoot   <- access _.rootPath
  (file, targetSymbol) <- getFile projectRoot sourceGlobal sourceSymbol globalsMap
  range         <- liftResult $ posToRange targetSymbol.pos cursorToken
  pure Location { uri = file, range = range }

findGlobal :: URI -> HashMap URI Global -> ServerResult Global
findGlobal uri globals = note Error "No global for given URI found" $ globals.lookup uri

findToken :: Position -> Global -> ServerResult Token
findToken cursorPos global = do 
    token  <- tokenUnderCursor cursorPos global
    case token.tokid of 
      id | id == T.VARID || id == T.CONID || id == T.QUALIFIER || id == T.SOMEOP -> pure token
      _ -> report "No valid token under cursor"

findSymbol :: Token -> Global -> ServerResult Symbol
findSymbol token global =  findSymbol'
   where 
     findSymbol' = do
       qname  <- note Error "No matching qname found"  $ global.resolved token >>= hush
       sym    <- note Error "No matching symbol found" $ global.find qname
       pure sym

tokenUnderCursor:: Position -> Global -> ServerResult Token
tokenUnderCursor cursorPos global =
  let
    tokens = global.sub.toks.toList
  in
  note Error "No token present under cursor" $ find isCursorOverToken tokens 
  where
    isCursorOverToken :: Token -> Bool
    isCursorOverToken t =
      -- token is 1 based, cursor 0
      cursorPos.line == (t.line - 1)
      && cursorPos.character < (t.col - 1 + (length t.value)) 
      && cursorPos.character >= t.col - 1

posToRange :: P.Position -> Token -> ServerResult Range
posToRange pos token = do
  let result = Range {
    -- token is 1 based, cursor 0
    start = Position { line = first.line - 1, character = first.col - 1 }
  , end   = Position { line = last.line  - 1, character = last.col  - 1 + len }
  }
  if result.start.line < 0 || result.start.character < 0 then
    report "Received illegal source position for this token"
  else pure result
  where 
    first = pos.first
    last  = pos.last
    len   = length token.value

getFile :: ServerResult URI -> Global -> Symbol -> HashMap URI Global -> LspEnv IO (URI, Symbol)
getFile root sourceGlobal sourceSymbol m = do
    r <- liftResult root
    case sourceSymbol.name of
      Local _ _ -> do 
        logInfo "local definition"
        uri <- liftResult $ asServerResult (URI.fromGlobal r sourceGlobal)
        pure (uri, sourceSymbol)
      name -> do
        let pack = name.getpack
        file <- liftResult $ asServerResult ( URI.fromPackage r sourceGlobal pack)
        updateURIGlobals file

        case lookup file m of
          Nothing -> do
            logInfo $ "not loaded as global: " ++ show file
            -- if the file is not loaded as global right now, 
            -- it is either an external package or a definition part of the prelude 
            -- in this case we just jump to the line of the import
            uri <- liftResult $ asServerResult (URI.fromGlobal r sourceGlobal)
            pure (uri, sourceSymbol)
          Just global  -> do 
            sym <- liftResult $ findSymbolInDifferentGlobal global sourceSymbol
            logInfo $ "already loaded a global: " ++ show file
            pure (file, sym)
  where
    findSymbolInDifferentGlobal :: Global -> Symbol -> ServerResult Symbol
    findSymbolInDifferentGlobal g s = 
           note Error "No matching symbol found" $ g.find s.name

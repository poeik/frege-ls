module ch.fhnw.lsp.messages.textdocument.definition.Definition where

import Compiler.types.Global(Global, Symbol)
import Compiler.types.Positions as P()
import Compiler.types.Symbols
import Compiler.types.QNames
import Compiler.types.NSNames
import Compiler.enums.TokenID as T()
import Compiler.types.Tokens(Token)
import Data.HashMap

import ch.fhnw.lsp.env.LspEnv
import ch.fhnw.lsp.utils.Globals(compileFileAndUpdateURIGlobals, findGlobal, findGlobalForModule, readGlobals)
import ch.fhnw.lsp.env.LspState
import ch.fhnw.lsp.messages.GeneralLspTypes
import ch.fhnw.lsp.messages.textdocument.definition.DefinitionTypes
import ch.fhnw.lsp.utils.Utils(tokenAt, note, hush)

processDefinitionMessage :: DefinitionRequestParams -> LspEnv IO Location
processDefinitionMessage params = do
  let currentUri = params.textDocument.uri
  let cursorPos  = params.position.{character <- (\c -> c + 1)}
  globalsMap    <- readGlobals
  sourceGlobal  <- liftResult $ findGlobal currentUri globalsMap
  cursorToken   <- liftResult $ findToken  cursorPos sourceGlobal 
  logInfo $ "Token under cursor: " ++ show cursorToken
  (file, pos)   <- findPosition cursorToken sourceGlobal
  logInfo $ "Symbol in file: \"" ++ file.getPath ++ "\" at position \"" ++ show pos ++ "\"."
  range         <- liftResult $ posToRange pos cursorToken
  pure Location { uri = file, range = range }

findPosition :: Token -> Global -> LspEnv IO (URI, P.Position)
findPosition cursorToken sourceGlobal = do 
  case sourceGlobal.resolved cursorToken of
    Nothing            -> liftResult $ report ("Could not find a position for the given token: " ++ show cursorToken)
    Just (Left ())     -> resolveNamespace -- left means it is a namespace
    Just (Right qname) -> resolveQName qname

  where
    resolveNamespace = do
      projectRoot      <- access _.rootPath >>= liftResult
      globals          <- access _.globals
      let moduleName = NSX cursorToken.value
      position <- liftResult $ case sourceGlobal.sub.nsPos.lookup moduleName of 
        Nothing   -> report ("Could not find module " ++ show moduleName)
        Just pos  -> pure pos
      file <- liftResult . asServerResult $ projectRoot.fromGlobal sourceGlobal
      pure (file, position)
    resolveQName qname = do
       projectRoot          <- access _.rootPath
       globals              <- readGlobals
       sourceSymbol         <- liftResult $ note Error "No matching symbol for qname found" $ sourceGlobal.find qname
       (file, targetSymbol) <- getFile projectRoot sourceGlobal sourceSymbol globals
       pure (file, targetSymbol.pos)

findToken :: Position -> Global -> ServerResult Token
findToken cursorPos global = do 
    token  <- tokenAt cursorPos global
    case token.tokid of 
      id | id == T.VARID || id == T.CONID || id == T.QUALIFIER || id == T.SOMEOP -> pure token
      t -> report $ "Token under cursor (" ++ show t ++ ") is not valid."

findSymbol :: Token -> Global -> ServerResult Symbol
findSymbol token global = findSymbol'
   where 
     findSymbol' = do
       qname  <- note Error "No matching qname found"  $ global.resolved token >>= hush
       sym    <- note Error "No matching symbol found" $ global.find qname
       pure sym

posToRange :: P.Position -> Token -> ServerResult Range
posToRange pos token = do
  let result = Range {
    -- token is 1 based, cursor 0
    start = Position { line = first.line - 1, character = first.col - 1 }
  , end   = Position { line = last.line  - 1, character = last.col  - 1 + len }
  }
  if result.start.line < 0 || result.start.character < 0 then
    report "Received illegal source position for this token"
  else pure result
  where 
    first = pos.first
    last  = pos.last
    len   = length token.value

getFile :: ServerResult URI -> Global -> Symbol -> HashMap URI Global -> LspEnv IO (URI, Symbol)
getFile root sourceGlobal sourceSymbol m = do
    r <- liftResult root
    case sourceSymbol.name of
      Local _ _ -> do 
        logInfo "The requested symbol is a local definition"
        uri <- liftResult $ asServerResult (URI.fromGlobal r sourceGlobal)
        pure (uri, sourceSymbol)
      name -> do
        let pack = name.getpack
        file <- liftResult $ asServerResult (URI.fromPackage r sourceGlobal pack)

        case lookup file m of
          Nothing -> do
              maybeGlobal <- compileFileAndUpdateURIGlobals file
              case maybeGlobal of 
                Nothing -> do
                  -- if the file is not loaded as global right now, 
                  -- it is either an external package or a definition part of the prelude 
                  -- in this case we just jump to the line of the import
                  logInfo $ "no global found for " ++ show file
                  findImportPos r sourceGlobal sourceSymbol
                Just global ->
                  findPosition global file
          Just global -> findPosition global file
  where
    findSymbolInDifferentGlobal :: Global -> Symbol -> ServerResult Symbol
    findSymbolInDifferentGlobal g s = 
           note Error "No matching symbol found" $ g.find s.name
    findImportPos r sourceGlobal sourceSymbol = do
           uri <- liftResult $ asServerResult (URI.fromGlobal r sourceGlobal)
           pure (uri, sourceSymbol)
    findPosition global file = do
           sym <- liftResult $ findSymbolInDifferentGlobal global sourceSymbol
           logInfo $ "loaded as global: " ++ show file
           pure (file, sym)

module ch.fhnw.lsp.messages.textdocument.Definition where

import Compiler.types.Global(Global, Symbol)
import Compiler.types.Positions as P()
import Compiler.types.Symbols
import Compiler.types.QNames
import Compiler.enums.TokenID as T()
import Compiler.types.Tokens(Token)
import Data.HashMap
import Data.List(find)

import ch.fhnw.lsp.env.LspEnv
import ch.fhnw.lsp.env.LspState
import ch.fhnw.lsp.messages.GeneralLspTypes
import ch.fhnw.lsp.messages.textdocument.DefinitionTypes
import ch.fhnw.lsp.utils.Utils

processDefinitionMessage :: Monad m => DefinitionRequestParams -> LspEnv m Location
processDefinitionMessage params = do
  let currentUri = params.textDocument.uri
  let cursorPos  = params.position
  globalsMap    <- getSub globals
  currentGlobal <- liftEither $ findGlobal currentUri globalsMap
  cursorToken   <- liftEither $ findToken  cursorPos currentGlobal 
  symbol        <- liftEither $ findSymbol cursorToken currentGlobal 
  projectRoot   <- getSub rootPath
  file          <- liftEither $ getFile projectRoot currentGlobal symbol globalsMap
  range         <- liftEither $ posToRange symbol.pos cursorToken
  pure Location { uri = file, range = range}

findGlobal :: URI -> HashMap URI Global -> Either String Global
findGlobal uri globals = note "No global for given URI found" $ globals.lookup uri

findToken :: Position -> Global -> Either String Token
findToken cursorPos global = do 
    token  <- tokenUnderCursor cursorPos global
    case token.tokid of 
      id | id == T.VARID || id == T.CONID || id == T.QUALIFIER || id == T.SOMEOP -> pure token
      _ -> Left "No valid token under cursor"

findSymbol :: Token -> Global -> Either String Symbol
findSymbol token global =  findSymbol'
   where 
     findSymbol' = do
       qname  <- note "No matching qname found"  $ global.resolved token >>= hush
       sym    <- note "No matching symbol found" $ global.find qname
       pure sym

tokenUnderCursor:: Position -> Global -> Either String Token
tokenUnderCursor cursorPos global =
  let
    tokens = global.sub.toks.toList
  in
  note "No token present under cursor" $ find isCursorOverToken tokens 
  where
    isCursorOverToken :: Token -> Bool
    isCursorOverToken t =
      -- token is 1 based, cursor 0
      cursorPos.line == (t.line - 1)
      && cursorPos.character < (t.col - 1 + (length t.value)) 
      && cursorPos.character >= t.col - 1

posToRange :: P.Position -> Token -> (String | Range)
posToRange pos token = do
  let result = Range {
    -- token is 1 based, cursor 0
    start = Position { line = first.line - 1, character = first.col - 1 }
  , end   = Position { line = last.line  - 1, character = last.col  - 1 + len }
  }
  if result.start.line < 0 || result.start.character < 0 then
    Left "Received illegal source position for this token"
  else pure result
  where 
    first = pos.first
    last  = pos.last
    len   = length token.value

getFile :: (String | URI)  -> Global -> Symbol -> HashMap URI Global -> (String | URI)
getFile root global symbol m = do
    r <- root
    case symbol.name of
      Local _ _ -> URI.fromGlobal r global
      name -> do
        let pack = name.getpack
        file <- URI.fromPackage r global pack
        if member file m then 
          pure file 
        else 
          -- if the file is not loaded as global right now, 
          -- it is either an external package or a definition part of the prelude 
          -- in this case we just jump to the line of the import
          URI.fromGlobal r global

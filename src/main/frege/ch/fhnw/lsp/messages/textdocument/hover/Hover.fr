module ch.fhnw.lsp.messages.textdocument.hover.Hover where

import Compiler.types.Global(Global)
import Compiler.types.QNames(QName)
import Compiler.types.Tokens(Token)
import Data.HashMap(HashMap)

import ch.fhnw.lsp.effects.MonadLog(MonadLog(logInfo))
import ch.fhnw.lsp.effects.MonadGlobals(MonadGlobals(readGlobals))
import ch.fhnw.lsp.env.App(AppResult, liftToApp)
import ch.fhnw.lsp.env.LspState(report, ServerResult, ServerError(Error))
import ch.fhnw.lsp.messages.GeneralLspTypes(URI(), MarkupContent(), Markdown, Position(Position), Range(Range))
import ch.fhnw.lsp.messages.textdocument.hover.HoverTypes(HoverRequestParams, HoverResult)
import ch.fhnw.lsp.utils.Utils(tokenAt, note, hush)
import ch.fhnw.lsp.utils.Documentation(documentSymbol)
import ch.fhnw.lsp.utils.Globals(findGlobal)

processHoverRequest :: (MonadLog m, MonadGlobals m) => HoverRequestParams -> AppResult m HoverResult
processHoverRequest params = do
  let currentUri = params.textDocument.uri
  let cursorPos  = params.position
  logInfo $ "requested hover for: " ++ currentUri.path ++  " at position: " ++ show cursorPos
  (documentation, range) <- hoverInformation currentUri cursorPos
  pure $ HoverResult { contents = documentation, range = range }

hoverInformation :: (MonadGlobals m) => URI -> Position -> AppResult m (MarkupContent, Range)
hoverInformation uri position = do
  globals                 <- readGlobals
  (token, sourceGlobal)   <- findToken position uri globals
  case tokenToQName token sourceGlobal >>= sourceGlobal.findit of
    Just sym -> pure $ (documentSymbol sourceGlobal sym, tokenToRange token)
    Nothing    -> liftToApp $ report "Could not find hover information for requested position"
    
findToken :: (Monad m) => Position -> URI -> HashMap URI Global -> AppResult m (Token, Global)
findToken pos uri globals = do
  global <- liftToApp $ findGlobal uri globals
  token  <- liftToApp $ tokenAt pos
    global
  pure (token, global)

tokenToQName :: Token -> Global -> Maybe QName
tokenToQName tok sourceGlobal = do
  case sourceGlobal.resolved tok of
    Just (Right qname) -> Just qname
    _ -> Nothing

tokenToRange :: Token -> Range
tokenToRange tok = Range { start, end }
  where 
    start = Position { line = tok.line, character = tok.col }
    end   = Position { line = tok.line, character = tok.col + tok.length }

module ch.fhnw.lsp.messages.textdocument.hover.Hover where

import Compiler.types.Global(Global)
import Compiler.types.QNames(QName)
import Compiler.types.Tokens(Token)
import Data.HashMap(HashMap)

import ch.fhnw.lsp.messages.GeneralLspTypes(URI, MarkupContent, Markdown, Position)
import ch.fhnw.lsp.env.LspEnv(LspEnv, logInfo, liftResult)
import ch.fhnw.lsp.env.LspState(report, ServerResult, ServerError(Error))
import ch.fhnw.lsp.messages.textdocument.hover.HoverTypes(HoverRequestParams, HoverResult)
import ch.fhnw.lsp.utils.Utils(tokenAt, note, hush)
import ch.fhnw.lsp.utils.Documentation(documentSymbol)
import ch.fhnw.lsp.utils.Globals(findGlobal, readGlobals)

processHoverRequest :: HoverRequestParams -> LspEnv IO HoverResult
processHoverRequest params = do
  let currentUri = params.textDocument.uri
  let cursorPos  = params.position.{character <- (+1)}
  logInfo $ "requested hover for: " ++ currentUri.getPath ++  " at position: " ++ show cursorPos
  documentation <- hoverInformation currentUri cursorPos
  pure $ HoverResult { contents = documentation }

hoverInformation :: URI -> Position -> LspEnv IO MarkupContent
hoverInformation uri position = do
  globals                 <- readGlobals
  (token, sourceGlobal)   <- findToken position uri globals
  case tokenToQName token sourceGlobal >>= sourceGlobal.findit of
    Just sym -> pure $ documentSymbol sourceGlobal sym
    Nothing    -> liftResult $ report "Could not find hover inforamtion for requested position"
    
findToken :: Position -> URI -> HashMap URI Global -> LspEnv IO (Token, Global)
findToken pos uri globals = do
  global <- liftResult $ findGlobal uri globals
  token  <- liftResult $ tokenAt pos
    global
  pure (token, global)

tokenToQName :: Token -> Global -> Maybe QName
tokenToQName tok sourceGlobal = do
  case sourceGlobal.resolved tok of
    Just (Right qname) -> Just qname
    _ -> Nothing


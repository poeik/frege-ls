module ch.fhnw.lsp.utils.Globals where

import Compiler.types.Global(Global)
import Compiler.types.NSNames(NSX)
import Control.concurrent.STM(atomically, TVar)
import Java.IO(File)

import ch.fhnw.lsp.messages.GeneralLspTypes(URI)
import ch.fhnw.lsp.utils.Utils(note)
import ch.fhnw.lsp.env.LspEnv
import ch.fhnw.lsp.env.LspState
import ch.fhnw.lsp.compile.CompileExecutorLSP
import ch.fhnw.lsp.utils.Utils(joinedBy)

import Data.HashMap

compileFile :: URI -> LspEnv IO (Maybe Global)
compileFile openedUri = do
    exists <- fileExists openedUri
    if exists then do
      logInfo $ "Compiling: " ++ openedUri.path
      pglobal    <- access _.projectGlobal >>= hushMaybe
      newGlobals <- liftIO $ compileMakeLSP openedUri.path pglobal
      updateURIGlobals newGlobals openedUri
    else do
      logInfo $ "File \"" ++ openedUri.path ++ "\" does not exist"
      pure Nothing
    where 
      fileExists :: URI -> LspEnv IO Bool
      fileExists u = liftIO file.exists 
        where 
          file = File.new u.path

compileInMemory :: URI -> String -> LspEnv IO (Maybe Global)
compileInMemory openedUri sourceCode = do
    pglobal    <- access _.projectGlobal >>= hushMaybe
    newGlobals <- liftIO $ compileMakeLSPInMemory openedUri.path sourceCode pglobal
    updateURIGlobals newGlobals openedUri

updateURIGlobals :: [Global] -> URI -> LspEnv IO (Maybe Global)
updateURIGlobals newGlobals openedUri = do
    logInfo $ "Adding " ++ show newGlobals.length ++ " globals: " ++ (show (map (URI.fromGlobal) newGlobals))
    rootPath   <- access _.rootPath >>= liftResult
    let kv = map (\g -> (URI.fromGlobal g, g)) newGlobals
    let globalsMap = fromList kv
    st <- get
    liftIO $ updateGlobals globalsMap st
    updated <- readGlobals
    liftEither $ Right (lookup openedUri updated)

findGlobal :: URI -> HashMap URI Global -> ServerResult Global
findGlobal uri globals = note Error ("No global for " ++ show uri ++ " in (" ++ (show . keys) globals ++") found") $ globals.lookup uri

findOrLoadGlobal :: URI -> LspEnv IO (Maybe Global)
findOrLoadGlobal uri = do
  globals <- readGlobals
  case (findGlobal uri globals) of
    Right !g -> pure $ Just g
    otherwise -> compileFile uri

findGlobalForModule :: String -> Global -> LspEnv IO (Maybe Global)
findGlobalForModule moduleName sourceGlobal = do
  uri  <- findFileUriForImportedModule moduleName sourceGlobal
  g    <- findOrLoadGlobal uri
  pure g

findFileUriForImportedModule :: String -> Global -> LspEnv IO URI
findFileUriForImportedModule moduleName sourceGlobal = do
  let mod = NSX moduleName
  globals     <- access _.globals
  projectRoot <- access _.rootPath >>= liftResult
  pack <- liftResult $ case sourceGlobal.namespaces.lookup mod of 
    Nothing  -> report ("Could not find module " ++ show mod)
    Just ps  -> pure ps
  uri  <- liftResult . asServerResult $ projectRoot.fromPackage sourceGlobal pack
  pure uri

readGlobals :: LspEnv IO (HashMap URI Global)
readGlobals = do
  globals <- access _.globals
  liftIO $ atomically globals.read

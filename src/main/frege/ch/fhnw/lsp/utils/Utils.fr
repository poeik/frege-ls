module ch.fhnw.lsp.utils.Utils where

import Compiler.types.Global(Global(), Symbol)
import Compiler.types.Tokens(Token())
import Data.HashMap(HashMap(), keys)
import Data.List(find)

import ch.fhnw.lsp.env.LspState(ServerResult, ServerError(Error))
import ch.fhnw.lsp.messages.GeneralLspTypes(Position(), URI())

hush :: Either e a -> Maybe a
hush (Right a) = Just a
hush (Left _)  = Nothing

note :: (e -> e') -> e ->  Maybe a -> Either e' a
note _ _ (Just a) = Right a
note f e Nothing  = Left $ f e

debug :: Show c => String -> c -> (a -> b) -> (a -> b)
debug lbl str f = 
  if traceLn (lbl ++ ": " ++ show str) 
    then f 
    else undefined

tokenAt:: Position -> Global -> ServerResult Token
tokenAt position global =
  let tokens = global.sub.toks.toList in
  note Error ("No token found at position" ++ show position) $ find findTokenAt tokens 
  where
    findTokenAt :: Token -> Bool
    findTokenAt t =
      position.line == t.line
      && position.character < (t.col + (length t.value)) 
      && position.character >= t.col

joinedBy :: [String] -> String -> String
joinedBy [] _ = ""
joinedBy (a:as) c = a ++ c ++ as `joinedBy` c


findGlobal :: URI -> HashMap URI Global -> ServerResult Global
findGlobal uri globals = note Error msg $ globals.lookup uri
  where 
    msg = (
      "No global for " 
      ++ show uri 
      ++ " in (" ++ (show . keys) globals 
      ++") found"
      )

